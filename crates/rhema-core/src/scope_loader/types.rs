use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::path::PathBuf;

/// Represents a package boundary detected by a plugin
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PackageBoundary {
    /// Path to the package root
    pub path: PathBuf,
    /// Package manager type
    pub package_manager: PackageManager,
    /// Package information
    pub package_info: PackageInfo,
    /// Dependencies
    pub dependencies: Vec<Dependency>,
    /// Scripts (for package managers that support them)
    pub scripts: HashMap<String, String>,
    /// Additional metadata
    pub metadata: HashMap<String, serde_json::Value>,
}

/// Supported package managers
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
pub enum PackageManager {
    Npm,
    Yarn,
    Pnpm,
    Cargo,
    Pip,
    Poetry,
    Go,
    Maven,
    Gradle,
    Nx,
    Custom(String),
}

impl PackageManager {
    pub fn as_str(&self) -> &str {
        match self {
            PackageManager::Npm => "npm",
            PackageManager::Yarn => "yarn",
            PackageManager::Pnpm => "pnpm",
            PackageManager::Cargo => "cargo",
            PackageManager::Pip => "pip",
            PackageManager::Poetry => "poetry",
            PackageManager::Go => "go",
            PackageManager::Maven => "maven",
            PackageManager::Gradle => "gradle",
            PackageManager::Nx => "nx",
            PackageManager::Custom(name) => name,
        }
    }
}

/// Package information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PackageInfo {
    pub name: String,
    pub version: String,
    pub description: Option<String>,
    pub author: Option<String>,
    pub license: Option<String>,
    pub repository: Option<String>,
}

/// Dependency information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Dependency {
    pub name: String,
    pub version: String,
    pub dependency_type: DependencyType,
}

/// Type of dependency
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum DependencyType {
    Runtime,
    Development,
    Peer,
    Optional,
    Build,
}

/// Scope suggestion generated by a plugin
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ScopeSuggestion {
    pub name: String,
    pub path: PathBuf,
    pub scope_type: ScopeType,
    pub confidence: f64,
    pub reasoning: String,
    pub files: Vec<PathBuf>,
    pub dependencies: Vec<String>,
    pub metadata: HashMap<String, serde_json::Value>,
}

/// Type of scope
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ScopeType {
    Package,
    Workspace,
    Monorepo,
    Service,
    Library,
    Application,
    Test,
    Documentation,
    Configuration,
    Custom(String),
}

impl ScopeType {
    pub fn as_str(&self) -> &str {
        match self {
            ScopeType::Package => "package",
            ScopeType::Workspace => "workspace",
            ScopeType::Monorepo => "monorepo",
            ScopeType::Service => "service",
            ScopeType::Library => "library",
            ScopeType::Application => "application",
            ScopeType::Test => "test",
            ScopeType::Documentation => "documentation",
            ScopeType::Configuration => "configuration",
            ScopeType::Custom(name) => name,
        }
    }
}

/// Plugin metadata
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PluginMetadata {
    pub name: String,
    pub version: String,
    pub description: String,
    pub supported_package_managers: Vec<String>,
    pub priority: u32,
}

/// Plugin configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PluginConfig {
    pub enabled: bool,
    pub priority: u32,
    pub settings: HashMap<String, serde_json::Value>,
}

/// Scope context loaded by a plugin
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ScopeContext {
    pub scope_name: String,
    pub package_manager: PackageManager,
    pub dependencies: Vec<Dependency>,
    pub scripts: HashMap<String, String>,
    pub metadata: HashMap<String, serde_json::Value>,
}

/// Plugin errors
#[derive(Debug, thiserror::Error)]
pub enum PluginError {
    #[error("IO error: {0}")]
    IoError(#[from] std::io::Error),
    
    #[error("JSON parsing error: {0}")]
    JsonError(#[from] serde_json::Error),
    
    #[error("YAML parsing error: {0}")]
    YamlError(#[from] serde_yaml::Error),
    
    #[error("Package manager not supported: {0}")]
    UnsupportedPackageManager(String),
    
    #[error("Invalid package configuration: {0}")]
    InvalidPackageConfig(String),
    
    #[error("Plugin not found: {0}")]
    PluginNotFound(String),
    
    #[error("Plugin execution failed: {0}")]
    PluginExecutionFailed(String),
    
    #[error("Configuration error: {0}")]
    ConfigurationError(String),
}

/// Registry errors
#[derive(Debug, thiserror::Error)]
pub enum RegistryError {
    #[error("Plugin already registered: {0}")]
    PluginAlreadyRegistered(String),
    
    #[error("Plugin not found: {0}")]
    PluginNotFound(String),
    
    #[error("Plugin configuration error: {0}")]
    ConfigurationError(String),
}

/// Scope loader errors
#[derive(Debug, thiserror::Error)]
pub enum ScopeLoaderError {
    #[error("Plugin error: {0}")]
    PluginError(#[from] PluginError),
    
    #[error("Registry error: {0}")]
    RegistryError(#[from] RegistryError),
    
    #[error("No plugins found for path: {0}")]
    NoPluginsFound(String),
    
    #[error("Scope creation failed: {0}")]
    ScopeCreationFailed(String),
    
    #[error("Configuration error: {0}")]
    ConfigurationError(String),
}
